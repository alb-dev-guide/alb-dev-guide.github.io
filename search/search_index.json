{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this guide This doc is a working document to cover how Alb--the compiler frontend for the Habit programming language --works and how to get started on contributing to the compiler. This guide is inspired by the excellent rustc-dev-guide for the Rust programming language.","title":"About this Guide"},{"location":"#about-this-guide","text":"This doc is a working document to cover how Alb--the compiler frontend for the Habit programming language --works and how to get started on contributing to the compiler. This guide is inspired by the excellent rustc-dev-guide for the Rust programming language.","title":"About this guide"},{"location":"todo/","text":"Coming soon...","title":"Todo"},{"location":"todo/#coming-soon","text":"","title":"Coming soon..."},{"location":"compiler-arch/overview/","text":"Compiler overview A brief tour of how alb compiles programs: Driver.hs is the entrypoint of alb. Compiler pipelines are defined in the buildPipeline function , which constitutes of the following phases, which in reality is made up of smaller passes: Desugaring Kind Inference Type Inference Specialization Normalization LC Generation And two additional \"backend\" phases where the work is passed on to mil-tools: Normalization Specialization In this chapter we will look into how each of these passes transform the code from a bird's eye view, and in more detail in the rest of the guide. Desugaring: After parsing is done, we will enter the compiler pipeline. First, the compiler will attempt to \"desugar\" the program; decomposing higher-lever features into core language constructs. As they will no longer have to deal with syntactic sugar, this step helps simplify the code for subsequent phases (and passes). In alb, we have the following passes: - fixityProgram : Resolving infix operators, i.e. rewriting 1 + 2 into applicative form (+) 1 2. - freshenProgram : \"Freshen\" by assigning unique name to each variable bindings, i.e. when there are variables that shadows another, give it a new unique name so as it does not conflict. - eliminateTuplesProgram : TODO - TODO By the end of the desugaring phase, the program will have been translated into a simpler subset of Habit, dubbed IMPEG .","title":"Compiler overview"},{"location":"compiler-arch/overview/#compiler-overview","text":"","title":"Compiler overview"},{"location":"compiler-arch/overview/#a-brief-tour-of-how-alb-compiles-programs","text":"Driver.hs is the entrypoint of alb. Compiler pipelines are defined in the buildPipeline function , which constitutes of the following phases, which in reality is made up of smaller passes: Desugaring Kind Inference Type Inference Specialization Normalization LC Generation And two additional \"backend\" phases where the work is passed on to mil-tools: Normalization Specialization In this chapter we will look into how each of these passes transform the code from a bird's eye view, and in more detail in the rest of the guide.","title":"A brief tour of how alb compiles programs:"},{"location":"compiler-arch/overview/#desugaring","text":"After parsing is done, we will enter the compiler pipeline. First, the compiler will attempt to \"desugar\" the program; decomposing higher-lever features into core language constructs. As they will no longer have to deal with syntactic sugar, this step helps simplify the code for subsequent phases (and passes). In alb, we have the following passes: - fixityProgram : Resolving infix operators, i.e. rewriting 1 + 2 into applicative form (+) 1 2. - freshenProgram : \"Freshen\" by assigning unique name to each variable bindings, i.e. when there are variables that shadows another, give it a new unique name so as it does not conflict. - eliminateTuplesProgram : TODO - TODO By the end of the desugaring phase, the program will have been translated into a simpler subset of Habit, dubbed IMPEG .","title":"Desugaring:"}]}