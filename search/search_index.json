{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this guide This doc is a working document to cover how Alb--the compiler frontend for the Habit programming language --works and how to get started on contributing to the compiler. This guide is inspired by the excellent rustc-dev-guide for the Rust programming language.","title":"About this Guide"},{"location":"#about-this-guide","text":"This doc is a working document to cover how Alb--the compiler frontend for the Habit programming language --works and how to get started on contributing to the compiler. This guide is inspired by the excellent rustc-dev-guide for the Rust programming language.","title":"About this guide"},{"location":"todo/","text":"Coming soon...","title":"Todo"},{"location":"todo/#coming-soon","text":"","title":"Coming soon..."},{"location":"compiler-arch/overview/","text":"Compiler overview A brief tour of how alb compiles programs: Compilation process begins in Driver.hs , the entrypoint of alb. When alb is invoked, it will: - Build options from passed in command line arguments and/or .alb dotfile. - Build a list of filepaths with findFiles from each path passed in, searching for valid .hb/.lhb files if path to directories were given. - After a list of filepaths have been constructed, load the files and attempt to lex and parse them by invoking readProgram (TODO: break down and explain steps of lexing/parsing), and perform \"Import Chasing\"; For each file, it will check the list of \"requires\" and building a list of dependencies to other files. - Then after parsing is done and no errors are encountered, build the compiler pipeline and execute it. This is where the magic happens. alb's compiler pipeline is defined in the buildPipeline function , which consists of the following \"phases\" (which themselves are made up of smaller \"passes\"): Desugaring Kind Inference Type Inference Specialization Normalization LC Generation Keen readers will also notice two additional stages in buildPipeline , LLVMed and Compiled. At the end of the frontend phases which ends with LC Generation, alb's job is done. The generated LC code is merely passed on to milc to do the hard work of emitting LLVM IR and machine code. In this chapter we will look into how each of these frontend phases transform the code from a bird's eye view, and in more detail in later chapters. Desugaring: First, the compiler will attempt to \"desugar\" the program; decomposing higher-lever features into core language constructs. As they will no longer have to deal with syntactic sugar, this step helps simplify the code for subsequent phases (and passes). In alb, we have the following passes: fixityProgram : Resolve infix operators, i.e. rewriting 1 + 2 into applicative form (+) 1 2. freshenProgram : \"Freshen\" by assigning unique name to each variable bindings, i.e. when there are variables that shadows another, give it a new unique name so as it does not conflict. eliminateTuplesProgram : TODO patternTuplesProgram : TODO generateTuples : TODO desugarProgram : TODO rewriteFunctionalNotation : TODO By the end of the desugaring phase, the program will have been translated into a simpler, compiler-friendly subset of Habit, dubbed IMPEG . We use IMPEG to do Kind Inference and Type Inference . Kind Inference and Type Inference: TODO","title":"Overview of the Compiler"},{"location":"compiler-arch/overview/#compiler-overview","text":"","title":"Compiler overview"},{"location":"compiler-arch/overview/#a-brief-tour-of-how-alb-compiles-programs","text":"Compilation process begins in Driver.hs , the entrypoint of alb. When alb is invoked, it will: - Build options from passed in command line arguments and/or .alb dotfile. - Build a list of filepaths with findFiles from each path passed in, searching for valid .hb/.lhb files if path to directories were given. - After a list of filepaths have been constructed, load the files and attempt to lex and parse them by invoking readProgram (TODO: break down and explain steps of lexing/parsing), and perform \"Import Chasing\"; For each file, it will check the list of \"requires\" and building a list of dependencies to other files. - Then after parsing is done and no errors are encountered, build the compiler pipeline and execute it. This is where the magic happens. alb's compiler pipeline is defined in the buildPipeline function , which consists of the following \"phases\" (which themselves are made up of smaller \"passes\"): Desugaring Kind Inference Type Inference Specialization Normalization LC Generation Keen readers will also notice two additional stages in buildPipeline , LLVMed and Compiled. At the end of the frontend phases which ends with LC Generation, alb's job is done. The generated LC code is merely passed on to milc to do the hard work of emitting LLVM IR and machine code. In this chapter we will look into how each of these frontend phases transform the code from a bird's eye view, and in more detail in later chapters.","title":"A brief tour of how alb compiles programs:"},{"location":"compiler-arch/overview/#desugaring","text":"First, the compiler will attempt to \"desugar\" the program; decomposing higher-lever features into core language constructs. As they will no longer have to deal with syntactic sugar, this step helps simplify the code for subsequent phases (and passes). In alb, we have the following passes: fixityProgram : Resolve infix operators, i.e. rewriting 1 + 2 into applicative form (+) 1 2. freshenProgram : \"Freshen\" by assigning unique name to each variable bindings, i.e. when there are variables that shadows another, give it a new unique name so as it does not conflict. eliminateTuplesProgram : TODO patternTuplesProgram : TODO generateTuples : TODO desugarProgram : TODO rewriteFunctionalNotation : TODO By the end of the desugaring phase, the program will have been translated into a simpler, compiler-friendly subset of Habit, dubbed IMPEG . We use IMPEG to do Kind Inference and Type Inference .","title":"Desugaring:"},{"location":"compiler-arch/overview/#kind-inference-and-type-inference","text":"TODO","title":"Kind Inference and Type Inference:"}]}